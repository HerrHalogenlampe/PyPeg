---------------

python -m coverage run  `which py.test`
python -m coverage html

----------------

python ~/pypeg_git/pypy/rpython/bin/rpython -Ojit target.py
^mit jit. ohne -Ojit für ohne

../../pypy/pytest.py

../../pypy/pytest.py -s -k set tests/jit.py



search implementieren, ma rausfinden wie das gecallt wird (ich glaub damit waren position captures gemeint)
lies die doku( http://www.inf.puc-rio.br/~roberto/lpeg/ ) (!!!) (hab ich gemacht, und daraus 1000 neue tests für 1000 neue bytecodes extrahiert)
tests aus den codeschnippseln in der doku machen (s.o., da geht noch mehr)
helloworld.lua in tests umwandeln (DONE! test_slow in test_vm.py)
bug call/backtracking vermutlich drin, mehr tests schreiben (bug gefixt, mehr tests müssen noch)
refactor: tuple/int choicepoint elemente in klasse auslagern, ReturnAddress, ChoicePoint erben von StackEntry(DONE! bin mir unsicher ob das so richtig is)
run: instructionlist als parameter, index als parameter (DONE!)
    danach: refactor: aufruf der form "python vm_oderso.py patterndateiname, inputstringdateiname"
-pypy auschecken ( http://doc.pypy.org/en/latest/build.html bis "run the translation"

'lpeg.C(lpeg.P"a"/0)' ist ein problem. (-> numbered capture)
ich versteh pypy noch nich
das ding wo lua funktionen als semantische aktionen aufgerufen werden hab ich noch nicht geschnallt (vermutlich "/" operator)
captures sind noch mit tupeln implementiert, vermutlich in eigene klasse auslagern
    -> choicepoints auch (klasse mit backpointer)
captures gehen momentan nur mit "simple captures", 
andere capture typen beinhalten "argument","back","constant","fold","group","position","substitution","table","string","numbered","query","function","match-time"
(DONE)parser bug fixen(behind und capture bytecodes werden nicht anständig geparsed)

-------------
nachvollziehen wann die opencaptures erzeugt werden
(DONE)bug fixen: capture restore bei fail cases 
    --> speicher die capturelistlänge und schmeiß den rest weg(möglicher bug wenn capturelist nicht als stack verwendet wird, weil ich ja nur noch slice)
(DONE)todo: StackEntry.py zu stackentry.py umbenennen 
(DONE)todo: choicepoint erbt von returnaddress, returnaddress erbt von nix
(DONE)herausfinden ob lpeg n limit an captures hat oder dynamisch den stack anpasst
    -> methode doublecap in lpvm.c beantwortet die frage
(DONE)pypy: portable versuchen, pypy bitbucket
(DONE)vm.py main code in target.py auslagern (pypy konvention)
(DONE)partial commit: choicepoint mutaten anstatt runternehmen, neuen erzeugen, draufwerfen (performance)
(DONE)span: whileschleife in seperate funktion auslagern
(DONE)"in instruction.charlist" in hilfsmethode in Instruction auslagern
(DONE)bug im parser fixen(behind)(ggf. opencapture simple
vmoutput klasse erstellen die alles beinhält was nach vm.run sinnvoll verwendet werden könnte

neue tests in jit.py die alle bytecodes in schleifenstruktur enthalten
  - testset/set (done, cfbolz fragen ob das so darf)
  - call/ret (done, cfbolz fragen ob das so darf)

paper lesen:
 - dynamo
 - hotpath
 - meta-tracing pypy

sachen die ich mittwoch machen will:
-span optimieren (dafür wurde vm.spanloop angelegt)
-"in instruction.charlist" optimieren (dafür wurde instruction.incharlist angelegt)
    -> ggf. "char ranges" als klasse abspeichern um "in charrange" abfragen optimieren zu können
-jit tests besprechen (insbesondere testset/call/ret die recht "experimentelle" tests sind)
    ->jit tests optimieren
        (ich hab mir zwar die befehle geben lassen für das coole pygame interface zu step by step jitting aber ich bin da (noch) zu blöd für)
            ->nächstes mal mitschreiben was die kryptischen zwischencodes machen und welche operationen zu vermeiden sind
frage :wir haben letzte woche über einfach verkettete listen für captures/choicepoints gesprochen, liegt das noch aufm tisch)
    ->(glaube motivation dafür war der capture restore bug den ich momentan mit listenslicing gefixt habe)
frage: wie viele capturetypes wollen wir supporten (gibt noch ne ganze menge, siehe "capture typen")?
    ->blick auf rosie, wie läuft die abkopplung von parser/interpreter
unbekannte bytecodes igiveup, ibackcommit, icloseruntime, sind die wichtig, wenn ja wie komm ich an patterns die die erzeugen?


-------------
charlist in instruction refactorn(done)

zum span refactoring: (done)
    aktueller zustand ist tausend equals mit genau einem guard am ende
    gewünschter zustand ist <1000 geq/leq mit genau einem guard am ende


infrastruktur benchmarking
    -> skript was in lua lpeg / unser pypeg als exe (mit und ohne jit)
        (in ferner zukunft: lpeg ohne debug installieren)
        parametrisierbar mit inputfiles und patternfiles
    -> mehrfach ausführen, times messen, ergebnisse in json datei speichern
(4.-9. februar pypy arbeitswoche, da kann ich pypy lernen / an der BA arbeiten)
danach: mehr tests wie das email ding, für coolere benchmarks
jit test capture


google python keyword arguments

IEnd: done
IGiveup ?
IRet done
IAny done
ITestAny done (mega inkonsistent, consumed scheinbar input)
IChar done
ITestChar done
ISet done
ITestSet done
IBehind done (TODO: finde heraus was der bytecode soll)
ISpan: done
IJmp done
IChoice: done
ICall done
ICommit: done
IPartialCommit: done
IBackCommit?
IFailTwice done
IFail done
ICloseRunTime?
ICloseCapture done
IOpenCapture done
IFullCapture done


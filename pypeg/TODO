---------------

python -m coverage run  `which py.test`
python -m coverage html

----------------

python ~/pypeg_git/pypy/rpython/bin/rpython target.py

../../pypy/pytest.py

../../pypy/pytest.py -s -k email tests/jit.py



search implementieren, ma rausfinden wie das gecallt wird (ich glaub damit waren position captures gemeint) (hab jetzt simple capture support, das is ganz cool)
lies die doku( http://www.inf.puc-rio.br/~roberto/lpeg/ ) (!!!) (hab ich gemacht, und daraus 1000 neue tests für 1000 neue bytecodes extrahiert)
tests aus den codeschnippseln in der doku machen (s.o., da geht noch mehr)
helloworld.lua in tests umwandeln (DONE! test_slow in test_vm.py)
bug call/backtracking vermutlich drin, mehr tests schreiben (bug gefixt, mehr tests müssen noch)
refactor: tuple/int choicepoint elemente in klasse auslagern, ReturnAddress, ChoicePoint erben von StackEntry(DONE! bin mir unsicher ob das so richtig is)
run: instructionlist als parameter, index als parameter (DONE!)
    danach: refactor: aufruf der form "python vm_oderso.py patterndateiname, inputstringdateiname"
-pypy auschecken ( http://doc.pypy.org/en/latest/build.html bis "run the translation"

'lpeg.C(lpeg.P"a"/0)' ist ein problem. (-> numbered capture)
ich versteh pypy noch nich
das ding wo lua funktionen als semantische aktionen aufgerufen werden hab ich noch nicht geschnallt (vermutlich "/" operator)
captures sind noch mit tupeln implementiert, vermutlich in eigene klasse auslagern
    -> choicepoints auch (klasse mit backpointer)
captures gehen momentan nur mit "simple captures", 
andere capture typen beinhalten "argument","back","constant","fold","group","position","substitution","table","string","numbered","query","function","match-time"
parser bug fixen(behind und capture bytecodes werden nicht anständig geparsed)

-------------
nachvollziehen wann die opencaptures erzeugt werden
(DONE)bug fixen: capture restore bei fail cases 
    --> speicher die capturelistlänge und schmeiß den rest weg(möglicher bug wenn capturelist nicht als stack verwendet wird, weil ich ja nur noch slice)
(DONE)todo: StackEntry.py zu stackentry.py umbenennen 
(DONE)todo: choicepoint erbt von returnaddress, returnaddress erbt von nix (vererbung is raus, mag isinstance nicht)
(DONE)herausfinden ob lpeg n limit an captures hat oder dynamisch den stack anpasst
    -> methode doublecap in lpvm.c beantwortet die frage
(DONE)pypy: portable versuchen, pypy bitbucket
(DONE)vm.py main code in target.py auslagern (pypy konvention)
(DONE)partial commit: choicepoint mutaten anstatt runternehmen, neuen erzeugen, draufwerfen (performance)
(DONE)span: whileschleife in seperate funktion auslagern
(DONE)"in instruction.charlist" in hilfsmethode in Instruction auslagern
bug im parser fixen(behind)(ggf. opencapture simple)
charlist in instruction refactorn (ranges cooler abspeichern)
vmoutput klasse erstellen die alles beinhält was nach vm.run sinnvoll verwendet werden könnte

neue tests in jit.py die alle bytecodes in schleifenstruktur enthalten
  - testset/set
  - call/ret

paper lesen:
 - dynamo
 - hotpath
 - meta-tracing pypy

google python keyword arguments

freitag 14-16 uhr, john erklärt mir wie das mit den prozessen funktioniert


(bonus: capture)

code refactorn

IEnd: done
IGiveup ?
IRet done
IAny done
ITestAny done (mega inkonsistent, consumed scheinbar input)
IChar done
ITestChar done
ISet done
ITestSet done
IBehind done (TODO: finde heraus was der bytecode soll)
ISpan: done
IJmp done
IChoice: done
ICall done
ICommit: done
IPartialCommit: done
IBackCommit?
IFailTwice done
IFail done
ICloseRunTime?
ICloseCapture done
IOpenCapture done
IFullCapture done

